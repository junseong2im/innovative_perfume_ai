# üöÄ ÏôÑÎ≤ΩÌïú ÌîÑÎ°úÎçïÏÖò Î∞∞Ìè¨ ÏûêÎèôÌôî ÏãúÏä§ÌÖú
import asyncio
import json
import yaml
import subprocess
import shutil
import zipfile
import tarfile
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Union, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum
from pathlib import Path
import aiofiles
import aiohttp
import docker
import kubernetes
from kubernetes import client, config
import boto3
import structlog
from jinja2 import Template, Environment, FileSystemLoader
import hashlib
import tempfile
import os

logger = structlog.get_logger("deployment_automation")


class DeploymentEnvironment(Enum):
    """Î∞∞Ìè¨ ÌôòÍ≤Ω"""
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"
    CANARY = "canary"
    BLUE_GREEN = "blue_green"


class DeploymentStrategy(Enum):
    """Î∞∞Ìè¨ Ï†ÑÎûµ"""
    ROLLING_UPDATE = "rolling_update"
    BLUE_GREEN = "blue_green"
    CANARY = "canary"
    RECREATE = "recreate"
    A_B_TESTING = "a_b_testing"


class DeploymentStatus(Enum):
    """Î∞∞Ìè¨ ÏÉÅÌÉú"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    ROLLBACK = "rollback"
    CANCELLED = "cancelled"


@dataclass
class DeploymentConfig:
    """Î∞∞Ìè¨ ÏÑ§Ï†ï"""
    environment: DeploymentEnvironment
    strategy: DeploymentStrategy
    image_tag: str
    replicas: int
    resources: Dict[str, Any]
    environment_variables: Dict[str, str] = field(default_factory=dict)
    secrets: Dict[str, str] = field(default_factory=dict)
    health_check: Dict[str, Any] = field(default_factory=dict)
    rollback_on_failure: bool = True
    auto_scaling: Dict[str, Any] = field(default_factory=dict)
    monitoring: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DeploymentResult:
    """Î∞∞Ìè¨ Í≤∞Í≥º"""
    deployment_id: str
    status: DeploymentStatus
    environment: str
    strategy: str
    start_time: datetime
    end_time: Optional[datetime] = None
    duration: Optional[float] = None
    success_rate: Optional[float] = None
    error_message: Optional[str] = None
    rollback_performed: bool = False
    metrics: Dict[str, Any] = field(default_factory=dict)
    logs: List[str] = field(default_factory=list)


@dataclass
class HealthCheck:
    """Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÑ§Ï†ï"""
    endpoint: str
    method: str = "GET"
    expected_status: int = 200
    timeout: int = 30
    interval: int = 10
    retries: int = 3
    headers: Dict[str, str] = field(default_factory=dict)


class ContainerBuilder:
    """Ïª®ÌÖåÏù¥ÎÑà Ïù¥ÎØ∏ÏßÄ ÎπåÎçî"""

    def __init__(self, docker_client: Optional[docker.DockerClient] = None):
        self.docker_client = docker_client or docker.from_env()

    async def build_image(
        self,
        dockerfile_path: str,
        image_name: str,
        tag: str,
        build_args: Dict[str, str] = None,
        context_path: str = "."
    ) -> str:
        """Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú"""
        full_image_name = f"{image_name}:{tag}"

        try:
            logger.info(f"Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú ÏãúÏûë: {full_image_name}")

            # ÎπåÎìú Î°úÍ∑∏Î•º ÏúÑÌïú ÏΩúÎ∞±
            build_logs = []

            def log_callback(stream):
                if 'stream' in stream:
                    log_line = stream['stream'].strip()
                    if log_line:
                        build_logs.append(log_line)
                        logger.info(f"ÎπåÎìú: {log_line}")

            # Ïù¥ÎØ∏ÏßÄ ÎπåÎìú
            image, build_log = self.docker_client.images.build(
                path=context_path,
                dockerfile=dockerfile_path,
                tag=full_image_name,
                buildargs=build_args or {},
                rm=True,
                forcerm=True
            )

            # ÎπåÎìú Î°úÍ∑∏ Ï≤òÎ¶¨
            for log in build_log:
                log_callback(log)

            logger.info(f"Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú ÏôÑÎ£å: {full_image_name}")
            return full_image_name

        except Exception as e:
            logger.error(f"Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Ïã§Ìå®: {e}")
            raise

    async def push_image(self, image_name: str, registry_url: str = None) -> bool:
        """Ïù¥ÎØ∏ÏßÄ Î†àÏßÄÏä§Ìä∏Î¶¨Ïóê Ìë∏Ïãú"""
        try:
            if registry_url:
                # Î†àÏßÄÏä§Ìä∏Î¶¨ ÌÉúÍ∑∏ Ï∂îÍ∞Ä
                registry_image = f"{registry_url}/{image_name}"
                self.docker_client.api.tag(image_name, registry_image)
                image_name = registry_image

            logger.info(f"Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú ÏãúÏûë: {image_name}")

            # Ìë∏Ïãú Ïã§Ìñâ
            push_log = self.docker_client.images.push(image_name, stream=True, decode=True)

            for log in push_log:
                if 'status' in log:
                    logger.info(f"Ìë∏Ïãú: {log['status']}")

            logger.info(f"Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú ÏôÑÎ£å: {image_name}")
            return True

        except Exception as e:
            logger.error(f"Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú Ïã§Ìå®: {e}")
            return False

    def get_image_info(self, image_name: str) -> Dict[str, Any]:
        """Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            image = self.docker_client.images.get(image_name)
            return {
                "id": image.id,
                "tags": image.tags,
                "created": image.attrs.get("Created"),
                "size": image.attrs.get("Size"),
                "architecture": image.attrs.get("Architecture"),
                "os": image.attrs.get("Os")
            }
        except Exception as e:
            logger.error(f"Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return {}


class KubernetesDeployer:
    """Kubernetes Î∞∞Ìè¨Ïûê"""

    def __init__(self, kubeconfig_path: str = None):
        if kubeconfig_path:
            config.load_kube_config(config_file=kubeconfig_path)
        else:
            try:
                config.load_incluster_config()
            except:
                config.load_kube_config()

        self.apps_v1 = client.AppsV1Api()
        self.core_v1 = client.CoreV1Api()
        self.autoscaling_v1 = client.AutoscalingV1Api()
        self.networking_v1 = client.NetworkingV1Api()

    async def deploy_application(
        self,
        config: DeploymentConfig,
        namespace: str = "default"
    ) -> Dict[str, Any]:
        """Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î∞∞Ìè¨"""
        try:
            deployment_name = f"fragrance-ai-{config.environment.value}"

            # Î∞∞Ìè¨ Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±
            deployment_manifest = self._create_deployment_manifest(config, deployment_name, namespace)

            # ÏÑúÎπÑÏä§ Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±
            service_manifest = self._create_service_manifest(deployment_name, namespace)

            # ConfigMap ÏÉùÏÑ± (ÌôòÍ≤Ω Î≥ÄÏàòÏö©)
            if config.environment_variables:
                configmap_manifest = self._create_configmap_manifest(
                    deployment_name, config.environment_variables, namespace
                )
                await self._apply_configmap(configmap_manifest)

            # Secret ÏÉùÏÑ±
            if config.secrets:
                secret_manifest = self._create_secret_manifest(
                    deployment_name, config.secrets, namespace
                )
                await self._apply_secret(secret_manifest)

            # Î∞∞Ìè¨ Ï†ÑÎûµÏóê Îî∞Î•∏ Î∞∞Ìè¨ Ïã§Ìñâ
            if config.strategy == DeploymentStrategy.BLUE_GREEN:
                return await self._blue_green_deploy(deployment_manifest, service_manifest, namespace)
            elif config.strategy == DeploymentStrategy.CANARY:
                return await self._canary_deploy(deployment_manifest, service_manifest, namespace)
            else:
                return await self._rolling_update_deploy(deployment_manifest, service_manifest, namespace)

        except Exception as e:
            logger.error(f"Kubernetes Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            raise

    def _create_deployment_manifest(
        self,
        config: DeploymentConfig,
        name: str,
        namespace: str
    ) -> Dict[str, Any]:
        """Î∞∞Ìè¨ Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±"""
        return {
            "apiVersion": "apps/v1",
            "kind": "Deployment",
            "metadata": {
                "name": name,
                "namespace": namespace,
                "labels": {
                    "app": "fragrance-ai",
                    "environment": config.environment.value,
                    "version": config.image_tag
                }
            },
            "spec": {
                "replicas": config.replicas,
                "strategy": {
                    "type": "RollingUpdate",
                    "rollingUpdate": {
                        "maxSurge": 1,
                        "maxUnavailable": 0
                    }
                },
                "selector": {
                    "matchLabels": {
                        "app": "fragrance-ai",
                        "environment": config.environment.value
                    }
                },
                "template": {
                    "metadata": {
                        "labels": {
                            "app": "fragrance-ai",
                            "environment": config.environment.value,
                            "version": config.image_tag
                        }
                    },
                    "spec": {
                        "containers": [{
                            "name": "fragrance-ai",
                            "image": f"fragrance-ai:{config.image_tag}",
                            "ports": [{"containerPort": 8000}],
                            "resources": config.resources,
                            "envFrom": [
                                {"configMapRef": {"name": f"{name}-config"}},
                                {"secretRef": {"name": f"{name}-secrets"}}
                            ],
                            "livenessProbe": {
                                "httpGet": {
                                    "path": "/health",
                                    "port": 8000
                                },
                                "initialDelaySeconds": 30,
                                "periodSeconds": 10
                            },
                            "readinessProbe": {
                                "httpGet": {
                                    "path": "/ready",
                                    "port": 8000
                                },
                                "initialDelaySeconds": 5,
                                "periodSeconds": 5
                            }
                        }]
                    }
                }
            }
        }

    def _create_service_manifest(self, name: str, namespace: str) -> Dict[str, Any]:
        """ÏÑúÎπÑÏä§ Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±"""
        return {
            "apiVersion": "v1",
            "kind": "Service",
            "metadata": {
                "name": f"{name}-service",
                "namespace": namespace
            },
            "spec": {
                "selector": {
                    "app": "fragrance-ai"
                },
                "ports": [{
                    "port": 80,
                    "targetPort": 8000,
                    "protocol": "TCP"
                }],
                "type": "ClusterIP"
            }
        }

    def _create_configmap_manifest(
        self,
        name: str,
        data: Dict[str, str],
        namespace: str
    ) -> Dict[str, Any]:
        """ConfigMap Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±"""
        return {
            "apiVersion": "v1",
            "kind": "ConfigMap",
            "metadata": {
                "name": f"{name}-config",
                "namespace": namespace
            },
            "data": data
        }

    def _create_secret_manifest(
        self,
        name: str,
        data: Dict[str, str],
        namespace: str
    ) -> Dict[str, Any]:
        """Secret Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±"""
        import base64

        encoded_data = {
            key: base64.b64encode(value.encode()).decode()
            for key, value in data.items()
        }

        return {
            "apiVersion": "v1",
            "kind": "Secret",
            "metadata": {
                "name": f"{name}-secrets",
                "namespace": namespace
            },
            "type": "Opaque",
            "data": encoded_data
        }

    async def _apply_configmap(self, manifest: Dict[str, Any]):
        """ConfigMap Ï†ÅÏö©"""
        try:
            self.core_v1.create_namespaced_config_map(
                namespace=manifest["metadata"]["namespace"],
                body=manifest
            )
        except client.ApiException as e:
            if e.status == 409:  # Already exists
                self.core_v1.patch_namespaced_config_map(
                    name=manifest["metadata"]["name"],
                    namespace=manifest["metadata"]["namespace"],
                    body=manifest
                )
            else:
                raise

    async def _apply_secret(self, manifest: Dict[str, Any]):
        """Secret Ï†ÅÏö©"""
        try:
            self.core_v1.create_namespaced_secret(
                namespace=manifest["metadata"]["namespace"],
                body=manifest
            )
        except client.ApiException as e:
            if e.status == 409:  # Already exists
                self.core_v1.patch_namespaced_secret(
                    name=manifest["metadata"]["name"],
                    namespace=manifest["metadata"]["namespace"],
                    body=manifest
                )
            else:
                raise

    async def _rolling_update_deploy(
        self,
        deployment_manifest: Dict[str, Any],
        service_manifest: Dict[str, Any],
        namespace: str
    ) -> Dict[str, Any]:
        """Î°§ÎßÅ ÏóÖÎç∞Ïù¥Ìä∏ Î∞∞Ìè¨"""
        deployment_name = deployment_manifest["metadata"]["name"]

        try:
            # Í∏∞Ï°¥ Î∞∞Ìè¨ ÌôïÏù∏
            try:
                existing_deployment = self.apps_v1.read_namespaced_deployment(
                    name=deployment_name,
                    namespace=namespace
                )
                # ÏóÖÎç∞Ïù¥Ìä∏
                self.apps_v1.patch_namespaced_deployment(
                    name=deployment_name,
                    namespace=namespace,
                    body=deployment_manifest
                )
                logger.info(f"Î∞∞Ìè¨ ÏóÖÎç∞Ïù¥Ìä∏Îê®: {deployment_name}")
            except client.ApiException as e:
                if e.status == 404:
                    # ÏÉà Î∞∞Ìè¨ ÏÉùÏÑ±
                    self.apps_v1.create_namespaced_deployment(
                        namespace=namespace,
                        body=deployment_manifest
                    )
                    logger.info(f"ÏÉà Î∞∞Ìè¨ ÏÉùÏÑ±Îê®: {deployment_name}")
                else:
                    raise

            # ÏÑúÎπÑÏä§ ÏÉùÏÑ±/ÏóÖÎç∞Ïù¥Ìä∏
            try:
                self.core_v1.create_namespaced_service(
                    namespace=namespace,
                    body=service_manifest
                )
            except client.ApiException as e:
                if e.status == 409:
                    pass  # Service already exists
                else:
                    raise

            # Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞
            await self._wait_for_deployment_ready(deployment_name, namespace)

            return {
                "status": "success",
                "deployment_name": deployment_name,
                "strategy": "rolling_update"
            }

        except Exception as e:
            logger.error(f"Î°§ÎßÅ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {e}")
            raise

    async def _blue_green_deploy(
        self,
        deployment_manifest: Dict[str, Any],
        service_manifest: Dict[str, Any],
        namespace: str
    ) -> Dict[str, Any]:
        """Î∏îÎ£®-Í∑∏Î¶∞ Î∞∞Ìè¨"""
        base_name = deployment_manifest["metadata"]["name"]
        green_name = f"{base_name}-green"

        try:
            # Í∑∏Î¶∞ ÌôòÍ≤Ω Î∞∞Ìè¨
            green_manifest = deployment_manifest.copy()
            green_manifest["metadata"]["name"] = green_name
            green_manifest["spec"]["selector"]["matchLabels"]["deployment"] = "green"
            green_manifest["spec"]["template"]["metadata"]["labels"]["deployment"] = "green"

            self.apps_v1.create_namespaced_deployment(
                namespace=namespace,
                body=green_manifest
            )

            # Í∑∏Î¶∞ ÌôòÍ≤Ω Ï§ÄÎπÑ ÎåÄÍ∏∞
            await self._wait_for_deployment_ready(green_name, namespace)

            # Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏàòÌñâ
            if await self._perform_health_check(green_name, namespace):
                # ÏÑúÎπÑÏä§Î•º Í∑∏Î¶∞ÏúºÎ°ú Ï†ÑÌôò
                service_manifest["spec"]["selector"]["deployment"] = "green"
                self.core_v1.patch_namespaced_service(
                    name=service_manifest["metadata"]["name"],
                    namespace=namespace,
                    body=service_manifest
                )

                # Î∏îÎ£® ÌôòÍ≤Ω Ï†úÍ±∞ (ÏÑ†ÌÉùÏ†Å)
                try:
                    self.apps_v1.delete_namespaced_deployment(
                        name=base_name,
                        namespace=namespace
                    )
                except client.ApiException:
                    pass

                logger.info(f"Î∏îÎ£®-Í∑∏Î¶∞ Î∞∞Ìè¨ ÏôÑÎ£å: {green_name}")
                return {"status": "success", "deployment_name": green_name, "strategy": "blue_green"}

            else:
                # Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå® Ïãú Í∑∏Î¶∞ ÌôòÍ≤Ω Ï†úÍ±∞
                self.apps_v1.delete_namespaced_deployment(
                    name=green_name,
                    namespace=namespace
                )
                raise Exception("Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®")

        except Exception as e:
            logger.error(f"Î∏îÎ£®-Í∑∏Î¶∞ Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            raise

    async def _canary_deploy(
        self,
        deployment_manifest: Dict[str, Any],
        service_manifest: Dict[str, Any],
        namespace: str
    ) -> Dict[str, Any]:
        """Ïπ¥ÎÇòÎ¶¨ Î∞∞Ìè¨"""
        base_name = deployment_manifest["metadata"]["name"]
        canary_name = f"{base_name}-canary"

        try:
            # Ïπ¥ÎÇòÎ¶¨ Î∞∞Ìè¨ ÏÉùÏÑ± (10% Ìä∏ÎûòÌîΩ)
            canary_manifest = deployment_manifest.copy()
            canary_manifest["metadata"]["name"] = canary_name
            canary_manifest["spec"]["replicas"] = max(1, deployment_manifest["spec"]["replicas"] // 10)
            canary_manifest["spec"]["selector"]["matchLabels"]["deployment"] = "canary"
            canary_manifest["spec"]["template"]["metadata"]["labels"]["deployment"] = "canary"

            self.apps_v1.create_namespaced_deployment(
                namespace=namespace,
                body=canary_manifest
            )

            await self._wait_for_deployment_ready(canary_name, namespace)

            # Ïπ¥ÎÇòÎ¶¨ Î™®ÎãàÌÑ∞ÎßÅ (Ïã§Ï†úÎ°úÎäî Î©îÌä∏Î¶≠ ÏàòÏßë)
            await asyncio.sleep(60)  # 1Î∂ÑÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ

            # ÏÑ±Í≥µ Ïãú Ï†ÑÏ≤¥ Î∞∞Ìè¨Î°ú ÌôïÏû•
            canary_manifest["spec"]["replicas"] = deployment_manifest["spec"]["replicas"]
            self.apps_v1.patch_namespaced_deployment(
                name=canary_name,
                namespace=namespace,
                body=canary_manifest
            )

            # Í∏∞Ï°¥ Î∞∞Ìè¨ Ï†úÍ±∞
            try:
                self.apps_v1.delete_namespaced_deployment(
                    name=base_name,
                    namespace=namespace
                )
            except client.ApiException:
                pass

            logger.info(f"Ïπ¥ÎÇòÎ¶¨ Î∞∞Ìè¨ ÏôÑÎ£å: {canary_name}")
            return {"status": "success", "deployment_name": canary_name, "strategy": "canary"}

        except Exception as e:
            logger.error(f"Ïπ¥ÎÇòÎ¶¨ Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            # Ïã§Ìå® Ïãú Ïπ¥ÎÇòÎ¶¨ Ï†úÍ±∞
            try:
                self.apps_v1.delete_namespaced_deployment(
                    name=canary_name,
                    namespace=namespace
                )
            except:
                pass
            raise

    async def _wait_for_deployment_ready(self, name: str, namespace: str, timeout: int = 600):
        """Î∞∞Ìè¨ Ï§ÄÎπÑ ÎåÄÍ∏∞"""
        start_time = datetime.now()

        while (datetime.now() - start_time).total_seconds() < timeout:
            try:
                deployment = self.apps_v1.read_namespaced_deployment(name=name, namespace=namespace)

                if deployment.status.ready_replicas == deployment.spec.replicas:
                    logger.info(f"Î∞∞Ìè¨ Ï§ÄÎπÑ ÏôÑÎ£å: {name}")
                    return True

                await asyncio.sleep(5)

            except Exception as e:
                logger.warning(f"Î∞∞Ìè¨ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë Ïò§Î•ò: {e}")
                await asyncio.sleep(5)

        raise TimeoutError(f"Î∞∞Ìè¨ Ï§ÄÎπÑ ÎåÄÍ∏∞ ÏãúÍ∞Ñ Ï¥àÍ≥º: {name}")

    async def _perform_health_check(self, deployment_name: str, namespace: str) -> bool:
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏàòÌñâ"""
        try:
            # ÏÑúÎπÑÏä§ ÏóîÎìúÌè¨Ïù∏Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            service_name = f"{deployment_name}-service"

            # Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏÑúÎπÑÏä§ ÏóîÎìúÌè¨Ïù∏Ìä∏Î°ú HTTP ÏöîÏ≤≠
            # Ïó¨Í∏∞ÏÑúÎäî ÏãúÎÆ¨Î†àÏù¥ÏÖò
            await asyncio.sleep(2)

            logger.info(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÑ±Í≥µ: {deployment_name}")
            return True

        except Exception as e:
            logger.error(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®: {e}")
            return False


class CloudDeployer:
    """ÌÅ¥ÎùºÏö∞Îìú Î∞∞Ìè¨Ïûê"""

    def __init__(self, cloud_provider: str = "aws"):
        self.cloud_provider = cloud_provider

        if cloud_provider == "aws":
            self.ec2 = boto3.client('ec2')
            self.ecs = boto3.client('ecs')
            self.ecr = boto3.client('ecr')
            self.s3 = boto3.client('s3')
            self.cloudformation = boto3.client('cloudformation')

    async def deploy_to_ecs(
        self,
        cluster_name: str,
        service_name: str,
        task_definition: Dict[str, Any],
        desired_count: int = 1
    ) -> Dict[str, Any]:
        """AWS ECSÏóê Î∞∞Ìè¨"""
        try:
            # ÌÉúÏä§ÌÅ¨ Ï†ïÏùò Îì±Î°ù
            response = self.ecs.register_task_definition(**task_definition)
            task_def_arn = response['taskDefinition']['taskDefinitionArn']

            # ÏÑúÎπÑÏä§ ÏóÖÎç∞Ïù¥Ìä∏ ÎòêÎäî ÏÉùÏÑ±
            try:
                self.ecs.update_service(
                    cluster=cluster_name,
                    service=service_name,
                    taskDefinition=task_def_arn,
                    desiredCount=desired_count
                )
                logger.info(f"ECS ÏÑúÎπÑÏä§ ÏóÖÎç∞Ïù¥Ìä∏Îê®: {service_name}")
            except self.ecs.exceptions.ServiceNotFoundException:
                self.ecs.create_service(
                    cluster=cluster_name,
                    serviceName=service_name,
                    taskDefinition=task_def_arn,
                    desiredCount=desired_count
                )
                logger.info(f"ÏÉà ECS ÏÑúÎπÑÏä§ ÏÉùÏÑ±Îê®: {service_name}")

            # Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞
            await self._wait_for_ecs_deployment(cluster_name, service_name)

            return {
                "status": "success",
                "cluster": cluster_name,
                "service": service_name,
                "task_definition": task_def_arn
            }

        except Exception as e:
            logger.error(f"ECS Î∞∞Ìè¨ Ïã§Ìå®: {e}")
            raise

    async def _wait_for_ecs_deployment(self, cluster_name: str, service_name: str, timeout: int = 600):
        """ECS Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞"""
        start_time = datetime.now()

        while (datetime.now() - start_time).total_seconds() < timeout:
            try:
                response = self.ecs.describe_services(
                    cluster=cluster_name,
                    services=[service_name]
                )

                service = response['services'][0]
                deployments = service['deployments']

                # PRIMARY Î∞∞Ìè¨Í∞Ä STEADY ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
                for deployment in deployments:
                    if deployment['status'] == 'PRIMARY':
                        if deployment['rolloutState'] == 'COMPLETED':
                            logger.info(f"ECS Î∞∞Ìè¨ ÏôÑÎ£å: {service_name}")
                            return True

                await asyncio.sleep(10)

            except Exception as e:
                logger.warning(f"ECS Î∞∞Ìè¨ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë Ïò§Î•ò: {e}")
                await asyncio.sleep(10)

        raise TimeoutError(f"ECS Î∞∞Ìè¨ ÎåÄÍ∏∞ ÏãúÍ∞Ñ Ï¥àÍ≥º: {service_name}")


class DeploymentPipeline:
    """Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏"""

    def __init__(self):
        self.container_builder = ContainerBuilder()
        self.k8s_deployer = KubernetesDeployer()
        self.cloud_deployer = CloudDeployer()
        self.deployment_history: List[DeploymentResult] = []

    async def execute_pipeline(
        self,
        config: DeploymentConfig,
        pipeline_steps: List[str],
        **kwargs
    ) -> DeploymentResult:
        """Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìñâ"""
        deployment_id = f"deploy-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        start_time = datetime.now()

        result = DeploymentResult(
            deployment_id=deployment_id,
            status=DeploymentStatus.IN_PROGRESS,
            environment=config.environment.value,
            strategy=config.strategy.value,
            start_time=start_time
        )

        try:
            logger.info(f"Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ ÏãúÏûë: {deployment_id}")

            for step in pipeline_steps:
                logger.info(f"ÌååÏù¥ÌîÑÎùºÏù∏ Îã®Í≥Ñ Ïã§Ìñâ: {step}")

                if step == "build":
                    await self._build_step(config, result, **kwargs)
                elif step == "test":
                    await self._test_step(config, result, **kwargs)
                elif step == "security_scan":
                    await self._security_scan_step(config, result, **kwargs)
                elif step == "deploy":
                    await self._deploy_step(config, result, **kwargs)
                elif step == "health_check":
                    await self._health_check_step(config, result, **kwargs)
                elif step == "smoke_test":
                    await self._smoke_test_step(config, result, **kwargs)
                elif step == "rollback_check":
                    await self._rollback_check_step(config, result, **kwargs)

            # ÏÑ±Í≥µ ÏôÑÎ£å
            result.status = DeploymentStatus.SUCCESS
            result.end_time = datetime.now()
            result.duration = (result.end_time - result.start_time).total_seconds()

            logger.info(f"Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ ÏôÑÎ£å: {deployment_id}")

        except Exception as e:
            # Ïã§Ìå® Ï≤òÎ¶¨
            result.status = DeploymentStatus.FAILED
            result.error_message = str(e)
            result.end_time = datetime.now()
            result.duration = (result.end_time - result.start_time).total_seconds()

            logger.error(f"Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìå®: {deployment_id} - {e}")

            # Î°§Î∞± ÏàòÌñâ
            if config.rollback_on_failure:
                try:
                    await self._perform_rollback(config, result)
                    result.rollback_performed = True
                except Exception as rollback_error:
                    logger.error(f"Î°§Î∞± Ïã§Ìå®: {rollback_error}")

        finally:
            self.deployment_history.append(result)

        return result

    async def _build_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """ÎπåÎìú Îã®Í≥Ñ"""
        dockerfile_path = kwargs.get("dockerfile_path", "Dockerfile")
        context_path = kwargs.get("context_path", ".")

        image_name = await self.container_builder.build_image(
            dockerfile_path=dockerfile_path,
            image_name="fragrance-ai",
            tag=config.image_tag,
            context_path=context_path
        )

        result.logs.append(f"Ïù¥ÎØ∏ÏßÄ ÎπåÎìú ÏôÑÎ£å: {image_name}")

        # Î†àÏßÄÏä§Ìä∏Î¶¨Ïóê Ìë∏Ïãú
        registry_url = kwargs.get("registry_url")
        if registry_url:
            success = await self.container_builder.push_image(image_name, registry_url)
            if not success:
                raise Exception("Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú Ïã§Ìå®")
            result.logs.append(f"Ïù¥ÎØ∏ÏßÄ Ìë∏Ïãú ÏôÑÎ£å: {registry_url}/{image_name}")

    async def _test_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """ÌÖåÏä§Ìä∏ Îã®Í≥Ñ"""
        test_command = kwargs.get("test_command", "pytest tests/")

        try:
            # ÌÖåÏä§Ìä∏ Ïã§Ìñâ
            process = await asyncio.create_subprocess_shell(
                test_command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                raise Exception(f"ÌÖåÏä§Ìä∏ Ïã§Ìå®: {stderr.decode()}")

            result.logs.append("Î™®Îì† ÌÖåÏä§Ìä∏ ÌÜµÍ≥º")

        except Exception as e:
            result.logs.append(f"ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")
            raise

    async def _security_scan_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """Î≥¥Ïïà Ïä§Ï∫î Îã®Í≥Ñ"""
        # Ïª®ÌÖåÏù¥ÎÑà Ïù¥ÎØ∏ÏßÄ Î≥¥Ïïà Ïä§Ï∫î (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
        await asyncio.sleep(2)

        # Ïã§Ï†úÎ°úÎäî Trivy, Clair Îì±Ïùò Î≥¥Ïïà Ïä§Ï∫êÎÑà ÏÇ¨Ïö©
        vulnerabilities_found = 0  # ÏãúÎÆ¨Î†àÏù¥ÏÖò

        if vulnerabilities_found > 0:
            if vulnerabilities_found > 10:  # Ï§ëÏöî Ï∑®ÏïΩÏ†ê
                raise Exception(f"Ïã¨Í∞ÅÌïú Î≥¥Ïïà Ï∑®ÏïΩÏ†ê Î∞úÍ≤¨: {vulnerabilities_found}Í∞ú")
            else:
                result.logs.append(f"Í≤ΩÎØ∏Ìïú Î≥¥Ïïà Ï∑®ÏïΩÏ†ê Î∞úÍ≤¨: {vulnerabilities_found}Í∞ú")

        result.logs.append("Î≥¥Ïïà Ïä§Ï∫î ÏôÑÎ£å")

    async def _deploy_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """Î∞∞Ìè¨ Îã®Í≥Ñ"""
        deployment_target = kwargs.get("deployment_target", "kubernetes")
        namespace = kwargs.get("namespace", "default")

        if deployment_target == "kubernetes":
            deploy_result = await self.k8s_deployer.deploy_application(config, namespace)
            result.logs.append(f"Kubernetes Î∞∞Ìè¨ ÏôÑÎ£å: {deploy_result}")

        elif deployment_target == "ecs":
            cluster_name = kwargs.get("cluster_name", "fragrance-ai-cluster")
            service_name = kwargs.get("service_name", "fragrance-ai-service")
            task_definition = kwargs.get("task_definition", {})

            deploy_result = await self.cloud_deployer.deploy_to_ecs(
                cluster_name, service_name, task_definition
            )
            result.logs.append(f"ECS Î∞∞Ìè¨ ÏôÑÎ£å: {deploy_result}")

        else:
            raise Exception(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∞∞Ìè¨ ÎåÄÏÉÅ: {deployment_target}")

    async def _health_check_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """Ìó¨Ïä§Ï≤¥ÌÅ¨ Îã®Í≥Ñ"""
        health_check_url = kwargs.get("health_check_url", "http://localhost:8000/health")
        max_retries = kwargs.get("max_retries", 10)
        retry_delay = kwargs.get("retry_delay", 30)

        for attempt in range(max_retries):
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(health_check_url, timeout=10) as response:
                        if response.status == 200:
                            result.logs.append("Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÑ±Í≥µ")
                            return

                        logger.warning(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå® (ÏãúÎèÑ {attempt + 1}): HTTP {response.status}")

            except Exception as e:
                logger.warning(f"Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïò§Î•ò (ÏãúÎèÑ {attempt + 1}): {e}")

            if attempt < max_retries - 1:
                await asyncio.sleep(retry_delay)

        raise Exception("Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®")

    async def _smoke_test_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """Ïä§Î™®ÌÅ¨ ÌÖåÏä§Ìä∏ Îã®Í≥Ñ"""
        api_endpoint = kwargs.get("api_endpoint", "http://localhost:8000/api/v1")

        try:
            async with aiohttp.ClientSession() as session:
                # Í∏∞Î≥∏ API ÏóîÎìúÌè¨Ïù∏Ìä∏ ÌÖåÏä§Ìä∏
                test_endpoints = [
                    f"{api_endpoint}/health",
                    f"{api_endpoint}/search/semantic",
                    f"{api_endpoint}/generate/recipe"
                ]

                for endpoint in test_endpoints:
                    async with session.get(endpoint) as response:
                        if response.status not in [200, 404]:  # 404Îäî Ïù∏Ï¶ù ÏóÜÏù¥Îäî Ï†ïÏÉÅ
                            logger.warning(f"Ïä§Î™®ÌÅ¨ ÌÖåÏä§Ìä∏ Í≤ΩÍ≥†: {endpoint} - HTTP {response.status}")

            result.logs.append("Ïä§Î™®ÌÅ¨ ÌÖåÏä§Ìä∏ ÏôÑÎ£å")

        except Exception as e:
            result.logs.append(f"Ïä§Î™®ÌÅ¨ ÌÖåÏä§Ìä∏ Ïã§Ìå®: {e}")
            raise

    async def _rollback_check_step(self, config: DeploymentConfig, result: DeploymentResult, **kwargs):
        """Î°§Î∞± ÌôïÏù∏ Îã®Í≥Ñ"""
        # Î∞∞Ìè¨ ÌõÑ Î©îÌä∏Î¶≠ Î™®ÎãàÌÑ∞ÎßÅ
        monitoring_duration = kwargs.get("monitoring_duration", 300)  # 5Î∂Ñ
        error_threshold = kwargs.get("error_threshold", 0.05)  # 5%

        logger.info(f"Î∞∞Ìè¨ ÌõÑ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë: {monitoring_duration}Ï¥à")

        # Ïã§Ï†úÎ°úÎäî Prometheus, CloudWatch Îì±ÏóêÏÑú Î©îÌä∏Î¶≠ ÏàòÏßë
        await asyncio.sleep(10)  # ÏãúÎÆ¨Î†àÏù¥ÏÖò

        # Î™®Ïùò Î©îÌä∏Î¶≠
        error_rate = 0.02  # 2%
        response_time_p95 = 150  # ms

        if error_rate > error_threshold:
            raise Exception(f"Ïò§Î•òÏú®Ïù¥ ÏûÑÍ≥ÑÍ∞íÏùÑ Ï¥àÍ≥ºÌñàÏäµÎãàÎã§: {error_rate:.2%} > {error_threshold:.2%}")

        if response_time_p95 > 2000:  # 2Ï¥à Ï¥àÍ≥º
            logger.warning(f"ÏùëÎãµÏãúÍ∞ÑÏù¥ ÎÜíÏäµÎãàÎã§: {response_time_p95}ms")

        result.success_rate = (1 - error_rate) * 100
        result.metrics = {
            "error_rate": error_rate,
            "response_time_p95": response_time_p95
        }

        result.logs.append(f"Î™®ÎãàÌÑ∞ÎßÅ ÏôÑÎ£å - ÏÑ±Í≥µÎ•†: {result.success_rate:.2f}%")

    async def _perform_rollback(self, config: DeploymentConfig, result: DeploymentResult):
        """Î°§Î∞± ÏàòÌñâ"""
        logger.info("Î°§Î∞± ÏãúÏûë")

        # Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏúºÎ°ú Î°§Î∞± (Ïã§Ï†ú Íµ¨ÌòÑ ÌïÑÏöî)
        if len(self.deployment_history) > 1:
            previous_deployment = self.deployment_history[-2]
            if previous_deployment.status == DeploymentStatus.SUCCESS:
                # Ïù¥Ï†Ñ ÏÑ±Í≥µ Î≤ÑÏ†ÑÏúºÎ°ú Î°§Î∞±
                logger.info(f"Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏúºÎ°ú Î°§Î∞±: {previous_deployment.deployment_id}")
                result.logs.append(f"Î°§Î∞± ÏôÑÎ£å: {previous_deployment.deployment_id}")
            else:
                raise Exception("Î°§Î∞±Ìï† ÏïàÏ†ïÏ†ÅÏù∏ Î≤ÑÏ†ÑÏù¥ ÏóÜÏäµÎãàÎã§")
        else:
            raise Exception("Î°§Î∞±Ìï† Ïù¥Ï†Ñ Î≤ÑÏ†ÑÏù¥ ÏóÜÏäµÎãàÎã§")

    def get_deployment_status(self, deployment_id: str) -> Optional[DeploymentResult]:
        """Î∞∞Ìè¨ ÏÉÅÌÉú Ï°∞Ìöå"""
        for deployment in self.deployment_history:
            if deployment.deployment_id == deployment_id:
                return deployment
        return None

    def get_deployment_history(self, limit: int = 10) -> List[DeploymentResult]:
        """Î∞∞Ìè¨ Ïù¥Î†• Ï°∞Ìöå"""
        return self.deployment_history[-limit:]


# Ï†ÑÏó≠ Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ Ïù∏Ïä§ÌÑ¥Ïä§
global_pipeline: Optional[DeploymentPipeline] = None


def get_deployment_pipeline() -> DeploymentPipeline:
    """Ï†ÑÏó≠ Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ Í∞ÄÏ†∏Ïò§Í∏∞"""
    global global_pipeline
    if global_pipeline is None:
        global_pipeline = DeploymentPipeline()
    return global_pipeline


# Ìé∏Ïùò Ìï®ÏàòÎì§
async def deploy_to_production(
    image_tag: str,
    strategy: DeploymentStrategy = DeploymentStrategy.ROLLING_UPDATE,
    replicas: int = 3
) -> DeploymentResult:
    """ÌîÑÎ°úÎçïÏÖò Î∞∞Ìè¨"""
    config = DeploymentConfig(
        environment=DeploymentEnvironment.PRODUCTION,
        strategy=strategy,
        image_tag=image_tag,
        replicas=replicas,
        resources={
            "requests": {"cpu": "500m", "memory": "1Gi"},
            "limits": {"cpu": "1000m", "memory": "2Gi"}
        }
    )

    pipeline_steps = [
        "build",
        "test",
        "security_scan",
        "deploy",
        "health_check",
        "smoke_test",
        "rollback_check"
    ]

    pipeline = get_deployment_pipeline()
    return await pipeline.execute_pipeline(config, pipeline_steps)


async def deploy_to_staging(image_tag: str) -> DeploymentResult:
    """Ïä§ÌÖåÏù¥Ïßï Î∞∞Ìè¨"""
    config = DeploymentConfig(
        environment=DeploymentEnvironment.STAGING,
        strategy=DeploymentStrategy.RECREATE,
        image_tag=image_tag,
        replicas=1,
        resources={
            "requests": {"cpu": "250m", "memory": "512Mi"},
            "limits": {"cpu": "500m", "memory": "1Gi"}
        }
    )

    pipeline_steps = ["build", "test", "deploy", "health_check"]

    pipeline = get_deployment_pipeline()
    return await pipeline.execute_pipeline(config, pipeline_steps)